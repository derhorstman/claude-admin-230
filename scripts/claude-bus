#!/bin/bash
# claude-bus - VM Message Bus für Claude-Instanzen
# Redis Pub/Sub basiert

REDIS_HOST="192.168.42.253"
REDIS_PORT="6379"
REDIS_PASS="claudebus2026"
MY_IP=$(hostname -I | awk '{print $1}' | sed 's/192.168.42./\./')

redis_cmd() {
    redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" -a "$REDIS_PASS" --no-auth-warning "$@"
}

# Hilfe anzeigen
show_help() {
    echo "claude-bus - VM Message Bus"
    echo ""
    echo "Verwendung:"
    echo "  claude-bus send <ziel> <nachricht>   Nachricht an VM senden (.239, .253, etc)"
    echo "  claude-bus broadcast <nachricht>     An alle VMs senden"
    echo "  claude-bus listen                    Auf Nachrichten warten"
    echo "  claude-bus history [n]               Letzte n Nachrichten zeigen (default: 10)"
    echo "  claude-bus status                    Verbindungsstatus prüfen"
    echo ""
    echo "Beispiele:"
    echo "  claude-bus send .239 'Wie läuft Mogli?'"
    echo "  claude-bus broadcast 'System-Update in 5 Min'"
    echo "  claude-bus listen"
}

# Nachricht senden
send_message() {
    local target="$1"
    shift
    local message="$*"
    local timestamp=$(date -Iseconds)
    local channel="vm:${target}"

    # JSON erstellen
    local json=$(cat <<EOF
{"from":"${MY_IP}","to":"${target}","timestamp":"${timestamp}","type":"chat","message":"${message}"}
EOF
)

    # In Channel publishen
    redis_cmd PUBLISH "$channel" "$json" > /dev/null

    # In Stream für History speichern
    redis_cmd XADD "bus:history" MAXLEN "~" 1000 "*" \
        from "$MY_IP" to "$target" timestamp "$timestamp" message "$message" > /dev/null

    echo "[${MY_IP} → ${target}] $message"
}

# Broadcast an alle
broadcast_message() {
    local message="$*"
    local timestamp=$(date -Iseconds)

    local json=$(cat <<EOF
{"from":"${MY_IP}","to":"all","timestamp":"${timestamp}","type":"broadcast","message":"${message}"}
EOF
)

    redis_cmd PUBLISH "vm:all" "$json" > /dev/null
    redis_cmd XADD "bus:history" MAXLEN "~" 1000 "*" \
        from "$MY_IP" to "all" timestamp "$timestamp" message "$message" > /dev/null

    echo "[${MY_IP} → ALLE] $message"
}

# Auf Nachrichten warten
listen_messages() {
    echo "Warte auf Nachrichten für ${MY_IP} und Broadcasts..."
    echo "(Ctrl+C zum Beenden)"
    echo ""

    # Subscribe auf eigenen Channel und Broadcast
    redis_cmd --csv PSUBSCRIBE "vm:${MY_IP}" "vm:all" | while read line; do
        # Nachrichten parsen (pmessage format)
        if [[ "$line" == *'"message"'* ]]; then
            # JSON aus der Zeile extrahieren
            json=$(echo "$line" | sed 's/.*,"\({.*}\)"/\1/' | sed 's/\\"/"/g')
            if [[ -n "$json" && "$json" == "{"* ]]; then
                from=$(echo "$json" | grep -o '"from":"[^"]*"' | cut -d'"' -f4)
                msg=$(echo "$json" | grep -o '"message":"[^"]*"' | cut -d'"' -f4)
                type=$(echo "$json" | grep -o '"type":"[^"]*"' | cut -d'"' -f4)

                if [[ -n "$from" && -n "$msg" ]]; then
                    if [[ "$type" == "broadcast" ]]; then
                        echo "[BROADCAST von ${from}] $msg"
                    else
                        echo "[${from} → ${MY_IP}] $msg"
                    fi
                fi
            fi
        fi
    done
}

# History anzeigen
show_history() {
    local count="${1:-10}"
    echo "Letzte $count Nachrichten:"
    echo ""

    redis_cmd XREVRANGE "bus:history" + - COUNT "$count" | while read line; do
        if [[ "$line" =~ ^[0-9]+-[0-9]+$ ]]; then
            # Message ID - neue Nachricht beginnt
            :
        elif [[ "$line" == "from" ]]; then
            read from_val
            echo -n "[$from_val → "
        elif [[ "$line" == "to" ]]; then
            read to_val
            echo -n "$to_val] "
        elif [[ "$line" == "message" ]]; then
            read msg_val
            echo "$msg_val"
        fi
    done | tac  # Umkehren für chronologische Reihenfolge
}

# Status prüfen
check_status() {
    echo "Claude Bus Status"
    echo "================="
    echo "Redis Host: $REDIS_HOST:$REDIS_PORT"
    echo "Meine IP: $MY_IP"
    echo ""

    if redis_cmd PING | grep -q "PONG"; then
        echo "✓ Redis erreichbar"
    else
        echo "✗ Redis nicht erreichbar!"
        exit 1
    fi

    # Letzte Nachricht
    echo ""
    echo "Letzte Nachricht:"
    redis_cmd XREVRANGE "bus:history" + - COUNT 1 2>/dev/null
}

# Hauptlogik
case "$1" in
    send)
        if [[ -z "$2" || -z "$3" ]]; then
            echo "Fehler: Ziel und Nachricht erforderlich"
            echo "Beispiel: claude-bus send .239 'Hallo!'"
            exit 1
        fi
        shift
        target="$1"
        shift
        send_message "$target" "$@"
        ;;
    broadcast)
        if [[ -z "$2" ]]; then
            echo "Fehler: Nachricht erforderlich"
            exit 1
        fi
        shift
        broadcast_message "$@"
        ;;
    listen)
        listen_messages
        ;;
    history)
        show_history "$2"
        ;;
    status)
        check_status
        ;;
    *)
        show_help
        ;;
esac
